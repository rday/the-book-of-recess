<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="recess.04.01"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:ns52="http://www.w3.org/2000/svg"
         xmlns:ns5="http://www.w3.org/1999/xlink"
         xmlns:ns4="http://www.w3.org/1999/xhtml"
         xmlns:ns3="http://www.w3.org/1998/Math/MathML"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Recess Core</title>

  <para></para>

  <section>
    <title><literal>recess.lang </literal>as a language extensions to
    PHP</title>

    <para>Recess takes a different approach from many PHP web frameworks.
    Fundamental to the Recess 'Framework' is Recess 'Core', a shallow layer of
    classes that rest just above PHP in the architecture of Recess
    applications which provide extensions to the PHP language. These classes,
    located in <literal>recess.lang.*</literal>, are web framework agnostic,
    as we will see in the examples through this chapter. The Recess Framework
    is built upon Recess Core. By extending Recess'
    <classname>Object</classname> class, additional functionalities like the
    ability to 'attach' methods to a class at runtime, define methods that can
    be 'wrapped' by objects implementing <classname>IWrapper</classname>, and
    use Recess-style <literal>!Annotations</literal> are all enabled for
    user-defined classes.</para>

    <para>Where PHP stops short of providing language-level constructs for
    these useful capabilities found in other programming languages, Recess
    Core fills in the gaps with library-level support that is still distinctly
    PHP.</para>
  </section>

  <section>
    <title>The <classname>Library</classname> Class &amp; Autoloader</title>

    <para>The <classname>Library</classname> class' purpose is to simplify the
    inclusion of dependencies between classes. Under the covers
    <classname>Library</classname> uses an autoloading mechanism and some
    other techniques to ensure high-performance in applications that use
    Recess Core's functionalities. These caching and script compilation
    techniques will be discussed in-depth later.</para>

    <para><classname>Library</classname>'s most useful static methods are
    <methodname>addClassPath</methodname> and <methodname>import</methodname>.
    <classname>Library</classname> maintains a list of directories it attempts
    to find an imported class in. The exact location of imported class files
    can be cached by <classname>Library</classname> to avoid hitting disk
    multiple times to locate single files. The order in which paths are added
    to <classname>Library</classname> using
    <methodname>addClassPath</methodname> is important. When attempting to
    import a class paths are checked from the most-recently added to the
    least-recently added using <methodname>addClassPath</methodname>. The
    Recess Framework uses this mechanism to allow classes defined in
    <filename>plugins/</filename> to take precedence over
    <filename>recess/</filename>, and classes in <filename>apps/</filename> to
    take precedence over <filename>plugins/</filename>.</para>

    <para><classname>Library</classname>'s <literal>import</literal> style is
    inspired by Java/C# imports and is a stylistic difference from libraries
    like the Zend Framework. Suppose the following directory structure:</para>

    <para><screen>/public_html
   /foo
       ClassA.class.php
       /bar
           ClassB.class.php</screen>These classes can be imported using
    <classname>Library</classname> with the following snippet of PHP:</para>

    <para><example>
        <title>Using Library's <methodname>addClassPath</methodname> and
        <methodname>import</methodname> methods</title>

        <para><programlisting language="php">Library::addClassPath('/home/example/public_html');

Library::import('foo.ClassA');
$aClass = new AClass();

Library::import('foo.bar.ClassB');
$bClass = new BClass();</programlisting></para>
      </example></para>

    <para>If you ever need to use use <classname>Library</classname> and
    Recess classes in PHP files outside of the Recess Framework it requires
    setting up some environment variables and using
    <methodname>include</methodname> on Library directly. The following
    snippet can be placed into a php script and included by plain-old PHP
    files.</para>

    <para><note>
        <para>Recess' convention is one class definition per file. PHP files
        that contain class definitions must use the same name for the file as
        the class' name, followed by the extension ".class.php". So, for a
        class defined with <code language="php">class Foo { ... }</code> the
        filename would be <filename>Foo.class.php</filename>.</para>
      </note></para>

    <example>
      <title>core-bootstrap.php - Bootstrapping into Recess Core with
      <classname>Library</classname></title>

      <para><programlisting language="php">&lt;?php 
// core-bootstrap.php
// Bootstrap into Recess Core
date_default_timezone_set('America/New_York');

$_ENV['dir.bootstrap'] = str_replace('\\','/',realpath(dirname(__FILE__))) . '/';
$_ENV['url.base'] = str_replace(filename(__FILE__), '', $_SERVER['PHP_SELF']);

$_ENV['dir.recess'] = $_ENV['dir.bootstrap'] . 'recess/';
$_ENV['dir.temp'] = $_ENV['dir.bootstrap'] . 'data/temp/'; // This directory must be writeable by PHP

require($_ENV['dir.recess'] . 'recess/lang/Library.class.php');
Library::addClassPath($_ENV['dir.recess']);
Library::addClassPath($_ENV['dir.bootstrap'] . 'plugins/'); // Add additonal paths to Library's classpath
Library::addClassPath($_ENV['dir.bootstrap'] . 'apps/');
?&gt;</programlisting></para>
    </example>

    <para>These directory paths may need to be tweaked depending on where
    you've extracted the Recess distribution. Explanations for each of these
    environment variables follows:</para>

    <para><varname>$_ENV['dir.bootstrap']</varname> - The absolute directory
    that contains the bootstrap file. This is a helper variable that
    simplifies defining the other environment directories by reference.</para>

    <para><varname>$_ENV['dir.recess']</varname> - The base directory for
    Recess' source files. This directory should contain two subdirectories:
    <filename>recess/</filename> and <filename>test/</filename>.</para>

    <para><varname>$_ENV['dir.temp']</varname> - A directory that is writable
    by PHP scripts. This directory is used by Recess to store temporary data
    such as cached data structures or compiled scripts.</para>

    <para><varname>$_ENV['url.base']</varname> - This is the base URL path
    that relative URLs should be constructed from. Outside of the Recess
    Framework this is less meaningful. Recess uses it for mapping routes, and
    generating URLs in view helpers.</para>
  </section>

  <section>
    <title>The <classname>Object</classname> Class</title>

    <para><classname>Object</classname> is the base class for extensible
    classes in the Recess. <classname>Object</classname> introduces a standard
    for building a class descriptor through reflection and the realization of
    Recess Annotations. <classname>Object</classname> also introduces the
    ability to attach methods to a class at run-time and create wrappable
    methods.</para>

    <para><classname>Object</classname> is the superclass for the major
    components of Recess: <classname>Model</classname>s,
    <classname>Controller</classname>s, and <classname>View</classname>s. The
    two most common types of classes created when using the Recess Framework
    are Models and Controllers. There is nothing prohibiting developers from
    extending <classname>Object</classname> in their own custom classes. In
    fact, if you are a developer feeling particularly ambitious and needing to
    roll a mini-framework with a different composition than Recess, starting
    with <classname>Object</classname> and other primitives like
    <classname>Library</classname> defined in Recess Core will make your job
    much more pleasant!</para>

    <para>A primary purpose of any framework is to remove boilerplate code
    whereever possible. Object-oriented (OO) languages provide different means
    for removing code-duplication. The most commonly used techniques in
    well-known OO languages of Java and C++ are inheritance and composition.
    PHP has support for these common techniques and Recess makes use of them
    wherever possible. Other languages that support object-oriented
    programming like SmallTalk, Scala, and Ruby go beyond composition and
    inheritance and allow modules or traits to attach new units of
    functionality to class definitions (like properties and methods)
    dynamically. Recess Core provides a systematic way for simulating similar
    language features and allows for methods to be
    <emphasis>attached</emphasis> to classes that extend
    <classname>Object</classname> at run-time. This technique in combination
    with <emphasis>annotations</emphasis> is how the Recess ORM provides
    methods to access relationships, for example. Further discussion of
    <emphasis>attached methods</emphasis> see <xref
    linkend="section.core.attached-methods" />.</para>

    <para>Another form of extensibility in Recess that draws inspiration from
    a more sophisticated Aspect-Oriented Programming and the 'similar in
    spirit' Decorator OO pattern are <emphasis><link
    linkend="section.core.wrappable-methods">wrappable
    methods</link></emphasis>. Classes extending <classname>Object</classname>
    can declare a method to be <literal>!Wrappable</literal>. Once wrappable,
    other classes implementing the <interfacename>IWrapper</interfacename>
    interface can dynamically wrap functionality around calls to the method.
    Key methods in the framework, like <classname>Controller</classname>'s
    <methodname>serve</methodname> and <classname>Model</classname>'s
    <methodname>insert</methodname>, <methodname>update</methodname>,
    <methodname>delete</methodname>, are wrappable. Why is this useful? It
    allows user-defined functionality to inject behavior just before or just
    after core framework method calls in a standard way. For example,
    validations on a Model may take place just before
    <methodname>insert</methodname> or <methodname>update</methodname>, using
    wrappable methods the validation system does not need to be closely
    coupled to the Model class. Similarly with Controllers, authentication
    could happen before <methodname>serve</methodname> is called and the
    wrapping authentication class can subvert a request by redirecting to a
    login page. Further discussion on wrappable methods see <xref
    linkend="section.core.wrappable-methods" /></para>

    <para>The final major unit of functionality exposed in
    <classname>Object</classname> is a system for realizing <emphasis><link
    linkend="section.core.annotations">Recess Annotations</link></emphasis>.
    Annotations give programmers the ability to work in a more declarative,
    meta-programming style. What does this mean? Rather than telling PHP how
    to do something, you tell Recess what you want with an annotation and it
    is then up to Recess and the annotation's class to expand your declarative
    statement into PHP. Annotations can written on three PHP constructs:
    classes, methods, and properties. Because PHP does not have first-class
    support for annotations, Recess Annotations are placed inside of
    doccomments, comments that begin with <literal>/**</literal>, which are a
    first-class construct in PHP available through PHP's Reflection API.
    Annotations can make use of attached and wrappable methods to inject units
    of functionality. For further discussion on annotations see <xref
    linkend="section.core.annotations" /></para>

    <para>Underlying <link
    linkend="section.core.attached-methods"><emphasis>attached
    methods</emphasis></link>, <emphasis><link
    linkend="section.core.wrappable-methods">wrappable
    methods</link></emphasis>, and <link
    linkend="section.core.annotations"><emphasis>annotations</emphasis></link>
    is fundamental data structure, the <classname>ClassDescriptor</classname>.
    The <classname>ClassDescriptor</classname> is where the information used
    to describe Recess' language features like attached methods are stored.
    There is one <classname>ClassDescriptor</classname> per class and, when
    Recess is running in production mode, this data-structure is computed once
    and cached. Sub-classes of <classname>Object</classname> can use the class
    descriptor as a store for computed data structures by overriding hooks in
    the Object class. For example, <classname>Model</classname> uses this
    cache to hold database information and the meta-data for relationships,
    and <classname>Controller</classname> uses it to store routing
    information. Annotations expand to 'shape' a class'
    <classname>ClassDescriptor</classname>. The following section describes
    the hooks available to sub-classes of <classname>Object</classname> for
    shaping class descriptors.</para>

    <section>
      <title xml:id="section.core.class-descriptors">Hooks in
      <classname>Object</classname> while expanding Annotations and building
      <classname>ClassDescriptor</classname></title>

      <para><emphasis>Initialize Class Descriptor</emphasis> - A class's
      descriptor may need to initialize certain properties. For example
      <classname>Model</classname>'s descriptor has default properties
      initialized for database table based on convention by the name of the
      class, primary key, etc.</para>

      <para><code language="php">protected static function
      initClassDescriptor($class) - </code>Parameters:
      <parameter>$class</parameter> is the class' name as a string. Returns a
      <classname>ClassDescriptor</classname>.</para>

      <para><emphasis>Shape Descriptor with Method</emphasis> - Prior to
      expanding the annotations for a class method this hook is called to give
      a subclass an opportunity to manipulate its descriptor. For example
      Controller uses this in able to create default routes for methods which
      do not have explicit Route annotations.</para>

      <para><code language="php">protected static function
      shapeDescriptorWithMethod($class, $method, $descriptor,
      $annotations)</code>- Parameters: <parameter>$class</parameter> string
      name of class whose descriptor is being initialized.
      <parameter>$method</parameter> is of type
      <classname>ReflectionMethod</classname>.
      <parameter>$descriptor</parameter> is the
      <classname>ClassDescriptor</classname>.
      <parameter>$annotations</parameter> is an array of
      <classname>Annotation</classname>s found on method. Returns a
      <classname>ClassDescriptor</classname>.</para>

      <para><emphasis>Shape Descriptor with Property</emphasis> - Prior to
      expanding the annotations for a class property this hook is called to
      give a subclass an opportunity to manipulate its class descriptor. For
      example <classname>Model</classname> uses this to initialize the
      datastructure for a property before a !Column annotation applies
      metadata.</para>

      <para><code language="php">protected static function
      shapeDescriptorWithProperty($class, $property, $descriptor,
      $annotations)</code> - Parameters: <parameter>$class</parameter> string
      name of class whose descriptor is being initialized.
      <parameter>$property</parameter> is of type
      <classname>ReflectionProperty</classname>.
      <parameter>$descriptor</parameter> is the
      <classname>ClassDescriptor</classname>.
      <parameter>$annotations</parameter> is an array of
      <classname>Annotation</classname>s found on property. Returns a
      <classname>ClassDescriptor</classname>.</para>

      <para><emphasis>Finalize Class Descriptor</emphasis> - After all methods
      and properties of a class have been visited and annotations expanded
      this hook provides a sub-class a final opportunity to do post-processing
      and sanitization. For example, <classname>Model</classname> uses this
      hook to ensure consistency between <classname>Model</classname>'s
      descriptor and the actual database table's columns.</para>

      <para><code language="php">protected static function
      finalClassDescriptor($class, $descriptor)</code> - Parameters:
      <parameter>$class</parameter> is the class' name as a string.
      <parameter>$descriptor</parameter> is the
      <classname>ClassDescriptor</classname> after all properties and methods
      have been visited. Returns a
      <classname>ClassDescriptor</classname>.</para>
    </section>
  </section>

  <section>
    <title xml:id="section.core.attached-methods">Attached Methods</title>

    <para>Sub-classes of <classname>Object</classname> allow you to attach
    methods to a class dynamically at run-time. Once a method has been
    attached all instances of that class in existance, or instantiated
    thereafter, will have the method. Attached methods also show up with
    reflection when using the <classname>RecessReflectionClass</classname>.
    Example usages of attached methods are: the implementation of relationship
    methods on models, and wrappable methods. To attach a method to a class
    you must first define the target method on another class. The following
    detailed example demonstrates attaching a method to a class.</para>

    <para><example>
        <title>Attaching Methods to a sub-class of
        <classname>Object</classname></title>

        <para><programlisting language="php">&lt;?php
include('core-bootstrap.php');
Library::import('recess.lang.Object');

class MyRecessObject extends Object {} <co xml:id="attached-method.co1" />

class AttachedBehavior { <co revision="" xml:base=""
              xml:id="attached-method.co2" xml:lang="" />
  public $word = 'static';
  function targetMethod(Object $object<co revision="" xml:base=""
              xml:id="attached-method.co3" />, $lastWord) { echo "Hello, $this-&gt;word PHP $lastWord!"; }
}

$targetInstance = new AttachedBehavior();
$targetInstance-&gt;word = 'dynamic'; <co role="" xml:base=""
              xml:id="attached-method.co4" />
MyRecessObject::attachMethod('MyRecessObject', 'attachedMethod', $targetInstance, 'targetMethod'); <co
              xml:id="attached-method.co5" />

$myInstance = new MyRecessObject();
$myInstance-&gt;attachedMethod('world'); <co xml:id="attached-method.co6" />

// Output: Hello, dynamic PHP world!</programlisting></para>
      </example></para>

    <para><calloutlist>
        <callout arearefs="attached-method.co1">
          <para>The class we will attach a method to is
          <classname>MyRecessObject</classname>, it is important that it
          extends Recess' <classname>Object</classname> class.</para>
        </callout>

        <callout arearefs="attached-method.co2">
          <para>The class <classname>AttachedBehavior</classname> contains the
          method we will attach to <classname>MyRecessObject</classname>:
          <methodname>targetMethod</methodname>. Attached methods must be
          defined within a class because attaching requires an instance of the
          class as well as the method name.</para>
        </callout>

        <callout arearefs="attached-method.co3">
          <para>Notice that attached methods always take an instance of the
          class they are attached to as their first parameter. Subsequent
          parameters are the parameters to be passed by the attached method's
          call (6).</para>
        </callout>

        <callout arearefs="attached-method.co4">
          <para>We've created an instance of the
          <classname>AttachedBehavior</classname> class and given it some
          state. The ability to provide the method with some context is key to
          being able to do interesting things with attached methods on a
          class-by-class basis. For example, when a !HasMany or !BelongsTo
          annotation expands it attaches multiple methods to the class the
          annotation is defined on. Each of these target methods are defined
          on an instance of <classname>HasManyRelationship</classname> or
          <classname>BelongsToRelationship</classname> that have additional
          state, such as the relationship name, related table, foreign key,
          etc, that are vital state for the attached methods. One way to think
          of this is a poor man's closure.</para>
        </callout>

        <callout arearefs="attached-method.co5">
          <para>The call to the static method
          <methodname>attachMethod</methodname> is where the magic mapping
          happens. <classname>Object</classname> defines
          <methodname>attachedMethod</methodname> which has four parameters.
          The first is an unfortunate one: the string classname the method is
          being attached to<footnote>
              <para>This parameter a result of PHP &lt; 5.3's lack of late
              static binding. Even though the static method is invoked on the
              class we are attempting to attach the method to,
              <classname>MyRecessObject</classname>, until PHP 5.3 there is no
              means for determining the sub-class it was called on. After
              PHP5.3 this limitation has been fixed.</para>
            </footnote>. The second parameter is the name we are assigning to
          the new method on our class. So, in this example the method's name
          will be <methodname>attachedMethod().</methodname> Next we provide
          the target the attached method will call. We specify this by passing
          an instance of an object, and the string name of the method being
          attached.</para>
        </callout>

        <callout arearefs="attached-method.co6">
          <para>We can now call <methodname>attachedMethod</methodname> on an
          instance of <classname>MyRecessObject</classname> and it will map to
          <methodname>targetMethod</methodname> on our
          <classname>AttachedBehavior</classname> instance.</para>
        </callout>
      </calloutlist></para>

    <para>Underneath the covers there is some simple indirection taking place
    in <classname>Object</classname>'s <methodname>__call</methodname> method
    that maps the attached method call to the target method based on entries
    in the <classname>ClassDescriptor</classname>. If methods are attached
    during the process which sub-classes of <classname>Object</classname>
    expand annotations and build-up <classname>ClassDescriptor</classname>s
    then the target instance, its state, and the mapping will be automatically
    cached in production mode. For more information on
    <classname>ClassDescriptor</classname>, see <xref
    linkend="section.core.class-descriptors" /></para>
  </section>

  <section>
    <title
    xml:id="section.core.wrappable-methods"><literal>!Wrappable</literal>
    Methods and the <classname>IWrapper</classname> Interface</title>

    <para>Wrappable methods are special methods on an Object class whose
    invocations be dynamically 'wrapped' with new behavior before and/or after
    the invocation of the wrapped method. For Python coders method wrappers
    are similar to method decorators, for Aspect-Oriented folks this is a poor
    man's join-point, for everyone else wrappable methods are a flexible
    extensibility point where you can flexibly inject new behavior.</para>

    <para>Consider inheritance in traditional object-oriented programming. By
    overriding a method in a sub-class you can effectively wrap behavior
    around the parent class' method call. Here is some example code:</para>

    <para><example>
        <title>Wrapping a Method Using Traditional Inheritance</title>

        <para><programlisting language="php">&lt;?php
class MyBaseClass {
    function foo() { <co xml:base="" xml:id="inheritance.wrapping.co1" />
        echo "Foo!\n";
        return true;
    }
}

class MySubClass extends MyBaseClass {
    function echoFoo() { <co xml:id="inheritance.wrapping.co2" />
        echo "Before!\n"; 
        $result = parent::foo(); <co xml:id="inheritance.wrapping.co3"
              xml:lang="" />
        echo "After!\n"; <co xml:id="inheritance.wrapping.co4" xml:lang="" />
        return $result;
    }
}

$obj = new MySubclass();
$obj-&gt;echoFoo();
// Output:
//  Before!
//  Foo!
//  After!
?&gt;</programlisting></para>
      </example></para>

    <para><calloutlist>
        <callout arearefs="inheritance.wrapping.co1">
          <para><classname>MyBaseClass</classname> defines a method
          <methodname>foo</methodname> that will be 'wrapped' using
          inheritance.</para>
        </callout>

        <callout arearefs="inheritance.wrapping.co2">
          <para><methodname>foo</methodname> is overridden by
          <classname>MySubClass</classname> and first echos a message.</para>
        </callout>

        <callout arearefs="inheritance.wrapping.co3">
          <para>Now, we call the 'wrapped', or in this case overridden, parent
          class' <methodname>foo</methodname> method.</para>
        </callout>

        <callout arearefs="inheritance.wrapping.co4">
          <para>Finally, let's print an after message once the call to
          <classname>MyBaseClass</classname>' foo has returned.</para>
        </callout>
      </calloutlist>In this simple example we've effectively wrapped
    <classname>MyBaseClass</classname>' <methodname>foo</methodname> method
    with some new behavior: we print 'Before!' and 'After!'
    <methodname>foo</methodname> is called on instances of
    <classname>MySubClass</classname>. What is so bad about pure
    inheritance?</para>

    <para><itemizedlist>
        <listitem>
          <para>In many cases: Nothing, when you can use it, use it! If you
          can override methods to implement the functionality you need it is
          the best, most efficient way of 'wrapping' behavior around a method.
          Sometimes, though, it's painfully inflexible.</para>
        </listitem>

        <listitem>
          <para>Inflexibility - Inheritance is heirarchical. Our goal in
          <classname>MySubClass</classname> above was to print messages before
          and after a method call. Let's say we also wanted to log the outcome
          of the call to <methodname>foo</methodname>. We could create a new
          <classname>LoggedSubClass</classname> class that subclasses
          <classname>MySubClass</classname> and logs the result. Now we're
          ready to deploy and we want to get rid of the wrapped echo'ing
          behavior, to do so we must either change the parent class of
          <classname>LoggedSubClass</classname> or comment/toggle out the
          behavior in <classname>MySubClass</classname>.</para>
        </listitem>

        <listitem>
          <para>Duplication of Code - Suppose we wanted to have printing and
          logging capabilities wrap a bunch of method calls on a bunch of
          other classes. Without reorganizing the entire inheritance hierarchy
          we must duplicate similar code in many places around the
          application.</para>
        </listitem>
      </itemizedlist></para>

    <para>Other languages and programming paradigms have a fairly simple
    solution to these limitations, as mentioned Python's decorators and AOP's
    join-points, that Recess looked towards for inspiration. Recess' solution
    is called 'Wrappable' methods. A <literal>!Wrappable</literal> method can
    be wrapped by, (or decorated with), unbounded
    <classname>IWrapper</classname>s that can be composed dynamically at
    runtime. Let's take a look at how we could make
    <methodname>foo</methodname> a wrapped method:</para>

    <para><example>
        <title>Specifying a Wrappable Method</title>

        <para><programlisting language="php">&lt;?php
include('core-bootstrap.php');
Library::import('recess.lang.Object');

class MyBaseClass extends Object {
    /** !Wrappable foo */ <co xml:id="wrappable-method.co1" />
    function wrappedFoo() { <co xml:id="wrappable-method.co2" />
        echo "Foo!\n";
        return true;
    }
}

abstract class PrintWrapper implements IWrapper {}

$obj = new MyBaseClass();
$obj-&gt;foo(); <co xml:id="wrappable-method.co3" />

// Output:
//  Foo!</programlisting></para>
      </example><calloutlist>
        <callout arearefs="wrappable-method.co1">
          <para>The <literal>!Wrappable</literal> annotation can be used on
          methods to create a 'wrappable' method. Notice that
          <literal>foo</literal> follows <literal>!Wrappable</literal>, this
          indicates that the wrappable method will be invoked with the name
          <methodname>foo</methodname>.</para>
        </callout>

        <callout arearefs="wrappable-method.co2">
          <para>The actual name of the method is wrappedFoo. The only
          restriction on naming the wrapped method is that it can not have the
          same name as the wrappable method. By convention Recess prefixes
          wrapped methods with <literal>wrapped</literal>. I.E.
          <methodname>foo()</methodname> wraps
          <methodname>wrappedFoo()</methodname></para>
        </callout>

        <callout arch="" arearefs="wrappable-method.co3">
          <para>We can now invoke a method <methodname>foo()</methodname> on
          instances of <classname>MyBaseClass</classname>. Underneath the
          covers wrappable methods are surfaced using attached methods, for
          more info on attached methods see <xref
          linkend="section.core.attached-methods" />.</para>
        </callout>
      </calloutlist>Great! We have a wrappable foo method, now let's wrap it
    with printing behavior. All we need to do is create a
    <classname>PrintWrapper</classname> class that implements the
    <classname>IWrapper</classname> interface.</para>

    <para><example>
        <title>Implementing IWrapper</title>

        <para><programlisting language="php">// ... replace starting at previous example's definition of PrintWrapper ... 

class PrintWrapper implements IWrapper {
    function before($object, &amp;$arguments) { <co xml:id="iwrapper-co1" />
        echo "Before!\n";
    }

    function after($object, $returns) { <co xml:id="iwrapper-co2" />
        echo "After!\n";
        return $returns;
    }

    function combine(IWrapper $wrapper) { return false; } <co
              xml:id="iwrapper-co3" />
}

MyBaseClass::wrapMethod('MyBaseClass', 'foo', new PrintWrapper()); <co
              xml:id="iwrapper-co4" />

$obj = new MyBaseClass();
$obj-&gt;foo(); <co xml:id="iwrapper-co5" />
$obj-&gt;wrappedFoo(); <co xml:id="iwrapper-co6" />

// Output:
//  Before!
//  Foo!
//  After!
//  Foo!</programlisting></para>
      </example></para>

    <para><classname>PrintWrapper</classname> implements the three methods
    defined in the <classname>IWrapper</classname> interface. Let's discuss
    each:<calloutlist>
        <callout arearefs="iwrapper-co1">
          <para><methodname>before</methodname> is called before the wrapped
          method is called. It is passed a reference to the object the
          wrappable method has been called on, as well as an array of the
          arguments passed to the wrappable method. The arguments are passed
          by reference so that wrappers can transform what is eventually
          passed to the wrapped method. Not shown here, but if a wrapper's
          <methodname>before</methodname> method returns a non-null value it
          will short-circuit the call and return the value immediately to the
          callee without calling the wrapped method.</para>
        </callout>

        <callout arearefs="iwrapper-co2">
          <para><methodname>after</methodname> is called when the wrapped
          method returns. It is passed a reference to the object the wrappable
          method has been called on, and the return value of the wrapped
          method. The value <methodname>after</methodname> returns is passed
          to the calle so after has an opportunity to transform or replace the
          value returned from the wrapped method.</para>
        </callout>

        <callout arearefs="iwrapper-co3">
          <para><methodname>combine</methodname> is an optimization method
          that will be discussed shortly.</para>
        </callout>

        <callout arearefs="iwrapper-co4">
          <para>Here we use the static method
          <methodname>wrapMethod</methodname> to wrap a
          <classname>PrintWrapper</classname> instance on the wrappable method
          <methodname>foo</methodname> on
          <classname>MyBaseClass</classname>.</para>
        </callout>

        <callout arearefs="iwrapper-co5">
          <para>By invoking foo we first work our way through
          <classname>PrintWrapper</classname>'s
          <methodname>before()</methodname>, then call
          <classname>MyBaseClass</classname>'
          <methodname>wrappedFoo()</methodname>, and finally back out to
          <classname>PrintWrapper</classname>'s
          <methodname>after()</methodname>.</para>
        </callout>

        <callout arearefs="iwrapper-co6">
          <para>For the sake of being thorough we show that you can still call
          <methodname>wrappedFoo</methodname> directly. Because wrapped
          methods are implemented at the Recess Core library level and not
          directly in PHP there is no way around this.</para>
        </callout>
      </calloutlist>We now have the same printing behavior as in our
    Inheritanc example, but without using inheritance. The power and
    flexibility of wrappable methods and wrappers is that multiple wrappers
    can wrap a wrappable method. So we could create a logging wrapper that
    also wraps <methodname>foo</methodname> and easily flip either wrapper on
    or off, dynamically at run-time, without having to reorganize our class
    hierarchy. For more detail see <xref
    linkend="section.core.wrappable-methods.mechanics" />. Lets point out
    exactly how wrappable methods address the downsides of inheritance:</para>

    <para><itemizedlist>
        <listitem>
          <para>Wrappable methods avoid the <emphasis>inflexibility</emphasis>
          of inheritance-based overriding because methods can be wrapped
          dynamically. Wrapping methods with new functionality does not affect
          the type system or class hierarchy.</para>
        </listitem>

        <listitem>
          <para>Wrappable methods encapsulate a behavior around a method call.
          This presents a new way for PHP programs to package functionality to
          fight <emphasis>code duplication</emphasis>. To use Aspect-Oriented
          Programming terminology you could think of wrappers as a means for
          separating crosscutting concerns. Cross-cutting concerns are tasks
          like logging/printing debug messages as shown in the example above,
          authorization and access control, etc.</para>
        </listitem>
      </itemizedlist></para>

    <para>Given these two specific characteristics wrappable methods and
    wrappers provide a natural extensibility model. Plugin-developers can
    implement <classname>IWrapper</classname>s that application-developers can
    easily incorporate in their projects because there is no need to modify a
    class heirarchy and the plugin's wrapper behavior is encapsulated in a
    simple class. For application-developers, instantiating wrappers and
    applying them with the
    <classname>Object</classname>::<methodname>wrapMethod</methodname> API can
    be awkward and cumbersome. This is where Recess Core's annotations come to
    the rescue, annotations provide the perfect vehicle for making declarative
    statements about a class or method which then employ wrappers and attached
    methods to do the leg work under the covers. For more information on
    annotations, see <xref linkend="section.core.annotations" /></para>

    <section>
      <title xml:base="" xml:id="section.core.wrappable-methods.mechanics">The
      Mechanics of Wrapped Methods and Wrappers</title>

      <para>Where in the code base are wrapped methods implemented? What is
      the exact logic for processing methods wrapped with multiple wrappers?
      The answers to these questions are the focus of this section.</para>

      <para>The implementation of wrapped methods can be thought of as a
      combination of the Observer and Strategy design patterns with specific
      semantics. Wrappers are observers of wrapped methods who are notified
      before and after the wrapped method is called. The
      <methodname>before</methodname> and <methodname>after</methodname>
      aren't vanilla notifications, though, and can return values that affect
      the logic of the call similar to a strategy. The logic of wrapped method
      invocation is implemented in the
      <classname>recess.lang.WrappedMethod</classname> class. The
      <methodname>addWrappedMethod</methodname> in
      <classname>recess.lang.ClassDescriptor</classname> brings wrapped
      methods onto a class' descriptor, and, finally the
      <classname>recess.lang.WrappableAnnotation</classname> abstracts away
      the pattern of making a plain-old class method a wrappable
      method.</para>

      <para>When a wrapped method is invoked, the following process
      occurs:</para>

      <para><orderedlist>
          <listitem>
            <para>Statement <emphasis>S</emphasis> invokes wrapped method
            <emphasis>M</emphasis> on object <emphasis>O</emphasis> with
            arguments <emphasis>A*</emphasis>.</para>
          </listitem>

          <listitem>
            <para>Each wrapper's <methodname>before</methodname> method is
            invoked in the reverse order that the wrappers were added<footnote>
                <para><classname>IWrapper</classname> implementations must not
                depend on the order in which they are applied to a wrappable
                method.</para>
              </footnote>(LIFO). <methodname>before</methodname> is passed, by
            reference, <emphasis>O</emphasis> and an array of
            <emphasis>A*</emphasis>. The wrapper, thus, has an opportunity to
            get or set public state from <emphasis>O</emphasis> or any
            argument in <emphasis>A*</emphasis>. If a wrapper's
            <methodname>before</methodname> does not return a value or returns
            the value <literal>null</literal> then the next wrapper's before
            is called until all wrapper's <methodname>before</methodname>
            methods have been called. If a wrapper's
            <methodname>before</methodname> returns a non-null value this
            value does not pass go and does not collect two hundred dollars,
            it short-circuits the wrapper call-chain and is immediately
            returned to statement <emphasis>S</emphasis>.</para>
          </listitem>

          <listitem>
            <para>The call to the wrapped method <emphasis>M</emphasis> is
            made using the (potentially transformed) arguments
            <emphasis>A*</emphasis>. <emphasis>M</emphasis> returns value
            <emphasis>R</emphasis>.</para>
          </listitem>

          <listitem>
            <para>Each wrapper's <methodname>after</methodname> method is
            invoked in the order that the wrappers were added (FIFO).
            <methodname>after</methodname> is passed arguments
            <emphasis>O</emphasis> and <emphasis>R</emphasis>
            (<emphasis>M</emphasis>'s return value). If the call to a
            wrapper's <methodname>after</methodname> returns a non-null value
            then this return value, <emphasis>R'</emphasis>, will override
            <emphasis>R</emphasis> in the remaining wrapper's calls to
            <methodname>after</methodname>, else <emphasis>R'</emphasis> is
            set to <emphasis>R</emphasis>.</para>
          </listitem>

          <listitem>
            <para>The value <emphasis>R'</emphasis> is returned to
            <emphasis>S.</emphasis></para>
          </listitem>
        </orderedlist></para>

      <para><warning>
          <para>While nothing will stop you as an
          <classname>IWrapper</classname> author from writing the following at
          design-time, it should be noted that these practices will most
          likely cause errors and headaches at run-time and are considered
          <emphasis>really bad practice</emphasis>:</para>

          <para><itemizedlist>
              <listitem>
                <para>In <methodname>before</methodname>: changing the types
                of arguments in <emphasis>A*</emphasis>, or changing the
                number of arguments in <emphasis>A*</emphasis>.
                <emphasis>A*</emphasis> must remain such that using its
                elements to call method <emphasis>M</emphasis> will result in
                a valid method call with the arguments <emphasis>M</emphasis>
                expects.</para>
              </listitem>

              <listitem>
                <para>In <methodname>before</methodname>: returning a value of
                any type other than <emphasis>M</emphasis> could be expected
                to return.</para>
              </listitem>

              <listitem>
                <para>In <methodname>after</methodname>: returning a value
                <emphasis>R'</emphasis> of any type other than
                <emphasis>M</emphasis> could be expected to return.</para>
              </listitem>
            </itemizedlist></para>
        </warning></para>
    </section>

    <section>
      <title>Combining Method Wrappers with <classname>IWrapper</classname>'s
      <methodname>combine</methodname> method</title>

      <para>At runtime each wrapper is an instantiated object. In production
      mode these objects are deserialized on every request. Reducing the
      number-of wrappers is a boost to performance in time (extra method calls
      are expensive) and space so Recess gives <classname>IWrapper</classname>
      authors a simple way to combine similar wrappers. Imagine you've just
      created a <literal>!Required</literal> annotation that application
      developers can place on properties of a <classname>Model</classname> to
      denote they are required for <methodname>insert</methodname> and
      <methodname>update</methodname>. Beyind the scenes you've written a
      <classname>RequiredWrapper </classname>that takes the name of a property
      and in the <methodname>before</methodname> method checks to make sure
      the property's value is non-null. Each annotation would thus expand to
      wrap <methodname>insert</methodname> and <methodname>update</methodname>
      with a new instance of <classname>RequiredWrapper</classname> for every
      property on the model. That could mean a lot of
      <classname>IWrapper</classname> objects to call
      <methodname>before</methodname> and <methodname>after</methodname> on to
      check requiredness! (It would also mean you couldn't check more than one
      field for requiredness because of short-circuit returns!)</para>

      <para>When wrappers are applied to a
      <classname>WrappedMethod</classname> using
      <methodname>addWrapper</methodname> the
      <classname>WrappedMethod</classname> first iterates through each of the
      existing wrappers and calls their <methodname>combine</methodname>
      method, passing in the new wrapper. If the existing wrapper determines
      it can combine its state with the new wrapper's state it will do so and
      return true which indicates to the WrappedMethod <emphasis>"do not add
      this new wrapper to your list, I've taken on its duties"</emphasis>. If
      all existing wrapper's <methodname>combine</methodname> method returns
      false the new wrapper will be added to the list of registered wrappers.
      Let's take a look at an example:</para>

      <para><example>
          <title>Combining Wrappers</title>

          <para><programlisting language="php">&lt;?php
class RequiredWrapper implements IWrapper {
    protected $properties = array();
    function __construct($property) {
        $this-&gt;properties[] = $property;
    }

    function before($model, $args) {
        $missing = array();
        foreach($this-&gt;properties as $property) {
            if($model-&gt;$property === null) {
                $missing[] = $property;
            }
        }

        if(!empty($missing)) {
            print("The following properties are required: " . implode(", ", $missing);
            return false;
        } else {
            return true;
        }
    }

    function after($model, $returns) { }

    function combine(IWrapper $that) {
        if($wrapper instanceof RequiredWrapper) {
            $this-&gt;properties = array_merge($this-&gt;properties, $that-&gt;properties);
            return true;
        } else {
            return false;
        }
    }
}
?&gt;</programlisting></para>
        </example></para>
    </section>

    <section>
      <title>Using the <literal>!Before</literal> and
      <literal>!After</literal> Annotations</title>

      <para></para>
    </section>
  </section>

  <section>
    <title xml:id="section.core.annotations">Annotations</title>

    <para>Annotations can be introduced by extending the abstract class
    <classname>recess.lang.Annotation</classname>. <emphasis>User defined
    annotation classes must end in the word 'Annotation'. For example: to have
    a <literal>!Protected</literal> annotation the classname must be
    <classname>ProtectedAnnotation</classname>.</emphasis> There are four
    abstract methods which must be implemented by custom annotations:
    <methodname>usage</methodname>, <methodname>isFor</methodname>,
    <methodname>validate</methodname>, and <methodname>expand</methodname>.
    These methods are used by the framework to make working with user-defined
    annotations feel like a first-class PHP construct. Following are
    descriptions of the purpose for each annotation:</para>

    <para>usage - Returns a string representation of the intended usage of an
    annotation.</para>

    <para>isFor - Returns an integer representation of the type(s) of PHP
    language constructs the annotation is applicable to. Use the
    Annotation::FOR_* consts to return the desired result.<example>
        <title>Examples of Annotation's <methodname>isFor</methodname>
        Method</title>

        <para><programlisting language="php">// Only valid on classes
function isFor() { return Annotation::FOR_CLASS; }

// Valid on methods or properties
function isFor() { return Annotation::FOR_METHOD | Annotation::FOR_PROPERTY; }</programlisting></para>
      </example></para>

    <para><methodname>validate($class)</methodname> - Validate is called just
    before expansion. Because there may be multiple constraints of an
    annotation the implementation of validate should append any error messages
    to the protected <varname>$errors</varname> property. Commonly used
    validations helper methods are provided as protected methods on the
    Annotation class.</para>

    <para><methodname>expand($class, $reflection, $descriptor)</methodname> -
    The expansion step of an annotation gives it an opportunity to manipulate
    a class' descriptor by introducing additional metadata, attach methods,
    and wrap methods. Parameters: <parameter>$class</parameter> the classname
    the annotation is applied to. <parameter>$reflection</parameter> The PHP
    Reflection(Class|Method|Property) object the annotation is located on.
    <parameter>$descriptor</parameter> is the ClassDescriptor that the
    annotation is being expanded on.</para>

    <para>The power of annotations comes in the
    <methodname>expand</methodname> step. An annotation can modify a class'
    descriptor which allows for methods to be attached to a class and
    available on all instances of a class, as well as "wrap" methods of a
    class marked as <literal>!Wrappable</literal></para>

    <section>
      <title>Authoring an Annotation</title>

      <para>To demonstrate authoring a custom annotation, let's create an
      annotation for methods on a <classname>Controller</classname> that
      should be protected by a protected cookie key of "secret" and value of
      "password". Our goal is to be able to place
      <literal>!CookieProtected</literal> on a method in a controller and
      redirect users to an optionally specified path (else, "/") if they do
      not have the necessary cookie. We'll craft the annotation in two-steps,
      first we'll implement the abstract methods of
      <classname>Annotation</classname>, then we'll take combine the
      annotation with the previously discussed
      <classname>WrappedMethod</classname>s to finish off the functionality of
      the <classname>CookieProtectedAnnotation</classname> by wrapping a
      <classname>Controller</classname>'s <methodname>serve</methodname>
      method.</para>

      <para><example>
          <title>The Beginnings of the <literal>!CookieProtected</literal>
          Annotation</title>

          <para><programlisting language="php">&lt;?php
Library::import('recess.lang.Annotation');

class CookieProtectedAnnotation extends Annotation {
    public function usage() {
        return '!CookieProtected [optional/redirect/path]';
    }

    public function isFor() {
        return Annotation::FOR_METHOD;
    }

    protected function validate($class) {
        $this-&gt;minimumParameterCount(0);
        $this-&gt;maximumParameterCount(1);
        $this-&gt;validOnInstancesOf($class, Controller::CLASSNAME);
    }

    protected function expand($class, $reflection, $descriptor) {}
}
?&gt;</programlisting></para>

          <para>Let's walk through each method. We can see
          <methodname>usage</methodname> simply returns a string demonstrating
          how to properly use an annotation in code.
          <methodname>isFor</methodname> shows that this annotation can only
          be applied to methods, so Recess with throw an error if the
          annotation is placed on a class or a property of a class. This is
          what we want as we are trying to protect methods of a controller.
          <methodname>validate</methodname> is making use of helper methods
          defined in <classname>Annotation</classname> for validating the
          formation of the annotation. These validations are used to check
          things like the number of parameters, which classes the annotation
          is meaningful for (in this case, only on subclasses of
          'Controller'), etc.</para>
        </example>The full list of helper methods for validate is:
      <methodname>acceptedKeys</methodname>,
      <methodname>requiredKeys</methodname>,
      <methodname>acceptedKeylessValues</methodname>,
      <methodname>acceptedIndexedValues</methodname>,
      <methodname>acceptedValuesForKey</methodname>,
      <methodname>acceptsNoKeylessValues</methodname>,
      <methodname>acceptsNoKeyedValues</methodname>,
      <methodname>validOnInstancesOf</methodname>,
      <methodname>minimumParameterCount</methodname>,
      <methodname>maximumParameterCount</methodname>,
      <methodname>exactParameterCount</methodname>. To understand the meaning
      of 'keys', 'indexed values', 'keyless values', you must understand the
      way recess interprets annotations. Recess parses an annotation by doing
      the following: 1) find an annotation by looking for an !Bang followed by
      whitespace, "<literal>!Bang</literal>". 2) Convert everything after the
      start of an annotation into a parameters array, <literal>!Bang foo, key:
      bar</literal> becomes <literal>array("foo", "key" =&gt;
      "bar")</literal>. 3) Instantiate the class named
      <classname>BangAnnotation</classname> and pass the parameters into the
      <classname>BangAnnotation</classname>instance's
      <methodname>init</methodname> method. Thus, every subclass of
      <classname>Annotation</classname> has a <varname>$parameters</varname>
      property which is this array. The helper methods provide convenient ways
      of checking the contents of this array during
      <methodname>validate</methodname>.</para>

      <para>Once <methodname>validate</methodname> has been run, if errors are
      found in the annotation's <varname>$errors</varname> property a
      <classname>RecessErrorException</classname> is thrown. If no errors are
      found, then the final step before <methodname>expand</methodname> is
      called is to make all keyed values in the <varname>$parameters</varname>
      array properties of the annotation instance and to append all keyless
      values of <varname>$parameters</varname> to the $values property. For
      example, the annotation <literal>!Bang foo, Key: bar</literal> becomes:
      <literal>$bang = new BangAnnotation(); $bang-&gt;init(array('foo', 'Key'
      =&gt; 'bar'));</literal> Finally, after Recess calls
      <methodname>expandAnnotation</methodname> (which, in turn, calls your
      user-defined <methodname>expand</methodname>), your
      <methodname>expand</methodname> can reference
      <property>$this-&gt;values[0]</property> to find
      <literal>'foo'</literal> and <property>$this-&gt;key</property> to get
      <literal>'bar'</literal>.</para>

      <para><note>
          <para>During the <methodname>init</methodname> method of
          <classname>Annotation</classname> all array keys are converted to
          lowercase.</para>
        </note></para>
    </section>
  </section>
</chapter>
