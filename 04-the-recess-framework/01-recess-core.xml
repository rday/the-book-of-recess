<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="recess.04.01"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:ns52="http://www.w3.org/2000/svg"
         xmlns:ns5="http://www.w3.org/1999/xlink"
         xmlns:ns4="http://www.w3.org/1999/xhtml"
         xmlns:ns3="http://www.w3.org/1998/Math/MathML"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Recess Core</title>

  <para></para>

  <section>
    <title><literal>recess.lang's</literal> language extensions to PHP</title>

    <para>Recess takes a different approach from many PHP web frameworks.
    Fundamental to the Recess 'Framework' is Recess 'Core', a shallow layer of
    classes that rest just above PHP in the architecture of Recess
    applications which provide extensions to the PHP language. These classes,
    located in <literal>recess.lang.*</literal>, are framework agnostic, as we
    will see in the examples through this chapter. By extending Recess'
    <classname>Object</classname> class, additional functionalities like the
    ability to 'attach' methods to a class at runtime, define methods that can
    be 'wrapped' by objects implementing <classname>IWrapper</classname>, and
    use Recess-style <literal>!Annotations</literal> are all enabled for
    user-defined classes.</para>

    <para>Where PHP stops short of providing language-level constructs for
    these useful capabilities found in other programming languages, Recess
    Core fills in the gaps with library-level support that is still distinctly
    PHP.</para>
  </section>

  <section>
    <title>The <classname>Library</classname> Class &amp; Autoloader</title>

    <para>The <classname>Library</classname> class' purpose is to simplify the
    inclusion of dependencies between classes. Under the covers
    <classname>Library</classname> uses an autoloading mechanism and some
    other techniques to ensure high-performance in applications that use
    Recess Core's functionalities. These caching and script compilation
    techniques will be discussed in-depth later.</para>

    <para><classname>Library</classname>'s most useful static methods are
    <methodname>addClassPath</methodname> and <methodname>import</methodname>.
    </para>

    <para>Its style is inspired by Java/C# imports and is a stylistic
    difference from the conventions libraries like the Zend Framework
    take.</para>

    <para><note>
        <para>Recess' convention is one class definition per file. PHP files
        that contain class definitions must use the same name for the file as
        the class' name, followed by the extension ".class.php". So, for a
        class defined with <code language="php">class Foo { ... }</code> the
        filename would be <filename>Foo.class.php</filename>.</para>
      </note></para>
  </section>

  <section>
    <title>The <classname>Object</classname> Class</title>

    <para></para>
  </section>

  <section>
    <title>Attached Methods</title>

    <para></para>
  </section>

  <section>
    <title>Wrapped Methods and <classname>IWrapper</classname></title>

    <para></para>
  </section>

  <section>
    <title>Annotations</title>

    <para>Annotations can be introduced by extending the abstract class
    <classname>recess.lang.Annotation</classname>. <emphasis>User defined
    annotation classes must end in the word 'Annotation'. For example: to have
    a <literal>!Protected</literal> annotation the classname must be
    <classname>ProtectedAnnotation</classname>.</emphasis> There are four
    abstract methods which must be implemented by custom annotations:
    <methodname>usage</methodname>, <methodname>isFor</methodname>,
    <methodname>validate</methodname>, and <methodname>expand</methodname>.
    These methods are used by the framework to make working with user-defined
    annotations feel like a first-class PHP construct. Following are
    descriptions of the purpose for each annotation:</para>

    <para>usage - Returns a string representation of the intended usage of an
    annotation.</para>

    <para>isFor - Returns an integer representation of the type(s) of PHP
    language constructs the annotation is applicable to. Use the
    Annotation::FOR_* consts to return the desired result.<example>
        <title>Examples of Annotation's <methodname>isFor</methodname>
        Method</title>

        <para><programlisting language="php">// Only valid on classes
function isFor() { return Annotation::FOR_CLASS; }

// Valid on methods or properties
function isFor() { return Annotation::FOR_METHOD | Annotation::FOR_PROPERTY; }</programlisting></para>
      </example></para>

    <para><methodname>validate($class)</methodname> - Validate is called just
    before expansion. Because there may be multiple constraints of an
    annotation the implementation of validate should append any error messages
    to the protected <varname>$errors</varname> property. Commonly used
    validations helper methods are provided as protected methods on the
    Annotation class.</para>

    <para><methodname>expand($class, $reflection, $descriptor)</methodname> -
    The expansion step of an annotation gives it an opportunity to manipulate
    a class' descriptor by introducing additional metadata, attach methods,
    and wrap methods. Parameters: <parameter>$class</parameter> the classname
    the annotation is applied to. <parameter>$reflection</parameter> The PHP
    Reflection(Class|Method|Property) object the annotation is located on.
    <parameter>$descriptor</parameter> is the ClassDescriptor that the
    annotation is being expanded on.</para>

    <para>The power of annotations comes in the
    <methodname>expand</methodname> step. An annotation can modify a class'
    descriptor which allows for methods to be attached to a class and
    available on all instances of a class, as well as "wrap" methods of a
    class marked as <literal>!Wrappable</literal></para>

    <section>
      <title>Writing an Annotation</title>

      <para>To demonstrate authoring a custom annotation, let's create an
      annotation for methods on a <classname>Controller</classname> that
      should be protected by a protected cookie key of "secret" and value of
      "password". Our goal is to be able to place
      <literal>!CookieProtected</literal> on a method in a controller and
      redirect users to an optionally specified path (else, "/") if they do
      not have the necessary cookie. We'll craft the annotation in two-steps,
      first we'll implement the abstract methods of
      <classname>Annotation</classname>, then we'll take combine the
      annotation with the previously discussed
      <classname>WrappedMethod</classname>s to finish off the functionality of
      the <classname>CookieProtectedAnnotation</classname> by wrapping a
      <classname>Controller</classname>'s <methodname>serve</methodname>
      method.</para>

      <para><example>
          <title>The Beginnings of the <literal>!CookieProtected</literal>
          Annotation</title>

          <para><programlisting language="php">&lt;?php
Library::import('recess.lang.Annotation');

class CookieProtectedAnnotation extends Annotation {
    public function usage() {
        return '!CookieProtected [optional/redirect/path]';
    }

    public function isFor() {
        return Annotation::FOR_METHOD;
    }

    protected function validate($class) {
        $this-&gt;minimumParameterCount(0);
        $this-&gt;maximumParameterCount(1);
        $this-&gt;validOnInstancesOf($class, Controller::CLASSNAME);
    }

    protected function expand($class, $reflection, $descriptor) {}
}
?&gt;</programlisting></para>

          <para>Let's walk through each method. We can see
          <methodname>usage</methodname> simply returns a string demonstrating
          how to properly use an annotation in code.
          <methodname>isFor</methodname> shows that this annotation can only
          be applied to methods, so Recess with throw an error if the
          annotation is placed on a class or a property of a class. This is
          what we want as we are trying to protect methods of a controller.
          <methodname>validate</methodname> is making use of helper methods
          defined in <classname>Annotation</classname> for validating the
          formation of the annotation. These validations are used to check
          things like the number of parameters, which classes the annotation
          is meaningful for (in this case, only on subclasses of
          'Controller'), etc.</para>
        </example>The full list of helper methods for validate is:
      <methodname>acceptedKeys</methodname>,
      <methodname>requiredKeys</methodname>,
      <methodname>acceptedKeylessValues</methodname>,
      <methodname>acceptedIndexedValues</methodname>,
      <methodname>acceptedValuesForKey</methodname>,
      <methodname>acceptsNoKeylessValues</methodname>,
      <methodname>acceptsNoKeyedValues</methodname>,
      <methodname>validOnInstancesOf</methodname>,
      <methodname>minimumParameterCount</methodname>,
      <methodname>maximumParameterCount</methodname>,
      <methodname>exactParameterCount</methodname>. To understand the meaning
      of 'keys', 'indexed values', 'keyless values', you must understand the
      way recess interprets annotations. Recess parses an annotation by doing
      the following: 1) find an annotation by looking for an !Bang followed by
      whitespace, "<literal>!Bang</literal>". 2) Convert everything after the
      start of an annotation into a parameters array, <literal>!Bang foo, key:
      bar</literal> becomes <literal>array("foo", "key" =&gt;
      "bar")</literal>. 3) Instantiate the class named
      <classname>BangAnnotation</classname> and pass the parameters into the
      <classname>BangAnnotation</classname>instance's
      <methodname>init</methodname> method. Thus, every subclass of
      <classname>Annotation</classname> has a <varname>$parameters</varname>
      property which is this array. The helper methods provide convenient ways
      of checking the contents of this array during
      <methodname>validate</methodname>.</para>

      <para>Once <methodname>validate</methodname> has been run, if errors are
      found in the annotation's <varname>$errors</varname> property a
      <classname>RecessErrorException</classname> is thrown. If no errors are
      found, then the final step before <methodname>expand</methodname> is
      called is to make all keyed values in the <varname>$parameters</varname>
      array properties of the annotation instance and to append all keyless
      values of <varname>$parameters</varname> to the $values property. For
      example, the annotation <literal>!Bang foo, Key: bar</literal> becomes:
      <literal>$bang = new BangAnnotation(); $bang-&gt;init(array('foo', 'Key'
      =&gt; 'bar'));</literal> Finally, after Recess calls
      <methodname>expandAnnotation</methodname> (which, in turn, calls your
      user-defined <methodname>expand</methodname>), your
      <methodname>expand</methodname> can reference
      <property>$this-&gt;values[0]</property> to find
      <literal>'foo'</literal> and <property>$this-&gt;key</property> to get
      <literal>'bar'</literal>.</para>

      <para><note>
          <para>In the <methodname>init</methodname> method of
          <classname>Annotation</classname>s all array keys are converted to
          lowercase.</para>
        </note></para>
    </section>
  </section>
</chapter>
